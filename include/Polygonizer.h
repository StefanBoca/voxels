// Copyright (c) 2013-2016, Stoyan Nikolov
// All rights reserved.
// Voxels Library, please see LICENSE for licensing details.
#pragma once

#include "Structs.h"
#include "MaterialMap.h"

namespace Voxels
{

/// Represents a vertex output from the polygonization process
///
struct PolygonVertex
{
	/// Vector containing the position of the vertex
	///
	float3 Position;

	/// Vector containing the secondary position of the vertex
	/// The secondary position must be used when a vertex is on a boundary
	/// where a transition mesh will be drawn. The W component contains
	/// adjacency information about the neighbors od the block that need to
	/// be active to use this secondary position.
	float4 SecondaryPosition;

	/// Normal vector to the surface in this vertex
	///
	float3 Normal;

	/// Packed texture indices used to select
	/// a textures for blending on this vertex
	union {
		struct {
			unsigned char Reserved;
			unsigned char Blend;
			unsigned char Uxz;
			unsigned char Txz;

			unsigned char Uny;
			unsigned char Upy;
			unsigned char Tny;
			unsigned char Tpy;
		} TextureIndices;

		unsigned TI[2];
	} Textures;
};

/// Contains all the polygons in a block of the surface
///
class BlockPolygons
{
public:

	/// IDs used to identify the faces of the block where a transition might occur
	///
	enum TransitionFaceId {
		YNeg,
		ZNeg,
		XNeg,

		YPos,
		ZPos,
		XPos,

		Face_Count
	};

	/// Unique ID of the block. A polygonizer instance will generate unique IDs
	/// on every run.
	/// @return the ID of the block
	virtual unsigned GetId() const = 0;

	/// Returns an array of vertices generated for this block by the polygonization
	/// @param count output param with the count of vertices
	/// @return an array of "count" vertices
	virtual const PolygonVertex* GetVertices(unsigned* count) const = 0;

	/// Indices generated by the polygonization process for this block.
	/// Not that the Polygonizer generates triangle lists. So every 3 indices
	/// form a triangle.
	/// @param count output param with the count of indices
	/// @return an array of "count" indices
	virtual const unsigned* GetIndices(unsigned* count) const = 0;

	/// Transition vertices generated for a specific face of the block
	/// @param face the ID of the face of the block
	/// @param count output param with the count of vertices
	/// @return an array of "count" vertices
	virtual const PolygonVertex* GetTransitionVertices(TransitionFaceId face, unsigned* count) const = 0;

	/// Transition indices generated for a specific face of the block
	/// @param face the ID of the face of the block
	/// @param count output param with the count of indices
	/// @return an array of "count" indices
	virtual const unsigned* GetTransitionIndices(TransitionFaceId face, unsigned* count) const = 0;

	/// Returns the coordinates of the minimal corner of the polygonized surface
	/// @return minimal corner coordinates
	virtual float3 GetMinimalCorner() const = 0;

	/// Returns the coordinates of the maximal corner of the polygonized surface
	/// @return maximal corner coordinates
	virtual float3 GetMaximalCorner() const = 0;
};

/// Statistics provided about the polygonization process
///
struct PolygonizationStatistics
{
	/// The count of blocks calculated
	///
	unsigned BlocksCalculated;

	/// The count of trivial cells encountered
	///
	unsigned TrivialCells;

	/// The count of polygonized cells
	///
	unsigned NonTrivialCells;

	/// The count of degenerate triangles removed
	///
	unsigned DegenerateTrianglesRemoved;

	static const unsigned CASES_COUNT = 16;
	/// Counts for all the cell cases encountered
	///
	unsigned PerCaseCellsCount[CASES_COUNT];
};

/// Represents a whole polygonized surface
///
class PolygonSurface
{
public:
	/// A triplet indicating the extents of the whole surface
	/// @return the Width, Height and Depth of the surface
	virtual float3 GetExtents() const = 0;

	/// The count of LOD levels generated
	/// @return LOD levels count
	virtual unsigned GetLevelsCount() const = 0;

	/// The count of blocks generated for the specified LOD level
	/// @param level the LOD level
	/// @return count of blocks in "level"
	virtual unsigned GetBlocksForLevelCount(unsigned level) const = 0;

	/// Returns a block for a LOD level
	/// @param level the LOD level from which to retrieve the block
	/// @param id a *linear* id of the block. For a LOD level the id ranges from
	/// 0 to GetBlocksForLevelCount(level)
	/// @return the block requested or nullptr if the id or level are invalid
	virtual const BlockPolygons* GetBlockForLevel(unsigned level, unsigned id) const = 0;

	/// Returns the statistics for the polygonization process
	/// @return statistics about the polygonization process
	virtual const PolygonizationStatistics* GetStatistics() const = 0;

	/// After the polygonization a material cache is saved in the polygon map.
	/// The cache is used to make subsequent grid modifications faster.
	/// This method returns the size of the cache in bytes.
	/// @return the size of the material cache
	virtual unsigned GetCacheSizeBytes() const = 0;

	/// Get the total size in bytes of the polygon data stored in this structure
	/// @return the total size in bytes of the polygon data
	virtual unsigned GetPolygonDataSizeBytes() const = 0;

	/// Destroys the Surface and frees all memory associated with it.
	/// All pointers retrieved through this object become invalid.
	virtual void Destroy() = 0;

    static const unsigned INVALID_ID;
};

/// Represents a "dirty" region you want to modify
///
struct Modification
{
	/// Creates a new empty modification region
	///
	static Modification* Create();

	/// Polygon surface to modify
	///
	PolygonSurface* Map;

	/// The minimal corner of the "dirty" region.
	/// In *grid* coordinates, i.e. Z is UP
	float3 MinCornerModified; // in GRID coordinates

	/// The maximal corner of the "dirty" region.
	/// In *grid* coordinates, i.e. Z is UP
	float3 MaxCornerModified; // in GRID coordinates

	/// Returns an array of modified blocks after the polygonization of the
	/// modified region.
	/// @param count output count of blocks in the modification array
	/// @return an array of "count" new blocks
	virtual const unsigned* GetModifiedBlocks(unsigned* count) const = 0;

	/// Destroys the modification structure and all the memory associated
	// with it. The retrieved block pointers are invalidated.
	virtual void Destroy() = 0;

	virtual ~Modification();
};

/// Polygonizes a Voxel grid
/// Outputs LOD levels with collections of blocks - each with vertices and indices.
class Polygonizer
{
public:
	/// Creates a new Polygonizer object
	///
	Polygonizer();
	~Polygonizer();

	/// Executes the polygonization algorithm on a Voxels grid
	/// @param grid the Voxel grid we wish to work on
	/// @param materials a material table that will map material ids in the
	/// voxels to texture ids in the output vertices
	/// @param modification optional modification structure when you want to update an
	/// already polygonized surface
	/// @return the polygonized surface
	PolygonSurface* Execute(const Grid& grid,
		const MaterialMap* materials,
		Modification* modification = nullptr);

private:
	Polygonizer(const Polygonizer&);
	Polygonizer& operator=(const Polygonizer&);

	class TransVoxelImpl* m_Impl;
};

}
